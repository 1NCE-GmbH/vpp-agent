syntax = "proto3";

package l3;

/* Static Routes */
message StaticRoute {
    enum RouteType {
        INTRA_VRF = 0;                  /* Forwarding is being done in the specified vrf_id only, or according to
                                           the specified outgoing interface. */
        INTER_VRF = 1;                  /* Forwarding is being done by lookup into a different VRF,
                                           specified as via_vrf_id field. In case of these routes, the outgoing
                                           interface should not be specified. The next hop IP address
                                           does not have to be specified either, in that case VPP does full
                                           recursive lookup in the via_vrf_id VRF. */
        DROP = 2;                       /* Drops the network communication designated for specific IP address */
    }
    RouteType type = 10;
    uint32 vrf_id = 1;                  /* VRF identifier, field required for remote client. This value should be
                                           consistent with VRF ID in static route key. If it is not, value from
                                           kley will be preffered and this field will be overriden.  */
    string dst_network = 3;             /* ip address + prefix in format <address>/<prefix> */
    string next_hop_addr = 4;           /* next hop address */
    string outgoing_interface = 5;      /* outgoing interface name */
    uint32 weight = 6;                  /* weight (used for unequal cost load balncing) */
    uint32 preference = 7;              /* The preference of the path. Lowest preference is preferred.  */
                                        /* Only paths with the best preference contribute to forwarding. */
                                        /* (a poor man's primary and backup) */
    uint32 via_vrf_id = 8;              /* Specifies VRF ID for the next hop lookup / recursive lookup */
}

/* IP ARP Entries */
message ARPEntry {
    string interface = 1;               /* interface to which this APR entry applies */
    string ip_address = 2;              /* IP address */
    string phys_address = 3;            /* MAC address matching to the IP */
    bool static = 4;                    /* TRUE if this is a static ARP entry */
}

message ProxyARP {
    message Interface {
        string name = 1;                /* name of the interface proxy arp is enabled for */
    }
    repeated Interface interfaces = 1;

    message Range {
        string first_ip_addr = 1;       /* first (starting) IP address of the proxy ARP range */
        string last_ip_addr = 2;        /* last (ending) IP address of the proxy ARP range  */
    }
    repeated Range ranges = 2;
}

/* Enables/disables IP neighbor scanning */
message IPScanNeighbor {
    enum Mode {                         /* IP scan neighbor mode. Disabled by default, it can be enabled
                                           for IPv4 or IPv6 separately, or for both of them*/
        DISABLED = 0;
        IPv4 = 1;
        IPv6 = 2;
        BOTH = 3;
    }
    Mode mode = 1;

    uint32 scan_interval = 2;
    uint32 max_proc_time = 3;
    uint32 max_update = 4;
    uint32 scan_int_delay = 5;
    uint32 stale_threshold = 6;
}