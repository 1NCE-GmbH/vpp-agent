syntax = "proto3";

package srv6;

message LocalSID {          /* SID(IPv6 Address) is part of key and NOT part of value(message) in ETCD key-value store */
    uint32 fibTableID = 1;  /* ID of FIB table where to install localsid entry */

    /* Configuration for end functions (all end functions are mutually exclusive) */
    End baseEndFunction = 2;
    EndX endFunctionX = 3;
    EndT endFunctionT = 4;
    EndDX2 endFunctionDX2 = 5;
    EndDX4 endFunctionDX4 = 6;
    EndDX6 endFunctionDX6 = 7;
    EndDT4 endFunctionDT4 = 8;
    EndDT6 endFunctionDT6 = 9;

    /* End function behavior of simple endpoint */
    message End {
        bool psp = 1;                   /* use PSP (penultimate segment POP of the SRH) or by default use USP (Ultimate Segment Pop of the SRH) */
    }

    /* End function behavior of endpoint with Layer-3 cross-connect*/
    message EndX {
        bool psp = 1;                   /* use PSP (penultimate segment POP of the SRH) or by default use USP (Ultimate Segment Pop of the SRH) */
        string outgoingInterface = 2;   /* name of cross-connected outgoing interface */
        string nextHop = 3;             /* next hop address for cross-connected link */
    }

    /* End function behavior of endpoint with specific IPv6 table lookup*/
    message EndT {
        bool psp = 1;                   /* use PSP (penultimate segment POP of the SRH) or by default use USP (Ultimate Segment Pop of the SRH) */
    }

    /* End function nehavior of endpoint with decapsulation and Layer-2 cross-connect (or DX2 with egress VLAN rewrite when VLAN notzero - not supported this variant yet)*/
    message EndDX2 {
        uint32 vlanTag = 1;             /* Outgoing VLAN tag */
        string outgoingInterface = 2;   /* name of cross-connected outgoing interface */
        string nextHop = 3;             /* next hop address for cross-connected link */
    }

    /* End function behavior of endpoint with decapsulation and IPv4 cross-connect*/
    message EndDX4 {
        string outgoingInterface = 1;   /* name of cross-connected outgoing interface */
        string nextHop = 2;             /* next hop address for cross-connected link */
    }

    /* End function behavior of endpoint with decapsulation and IPv6 cross-connect*/
    message EndDX6 {
        string outgoingInterface = 1;   /* name of cross-connected outgoing interface */
        string nextHop = 2;             /* next hop address for cross-connected link */
    }

    /* End function behavior of endpoint with decapsulation and specific IPv4 table lookup*/
    message EndDT4 {
        //TODO model this end function
    }

    /* End function behavior of endpoint with decapsulation and specific IPv6 table lookup*/
    message EndDT6 {
        //TODO model this end function
    }
}


/* Model for SRv6 policy (policy without at least one policy segment is only cached in ligato and not written to VPP)*/
message Policy {                        /* biding SID(IPv6 Address) is part of key and NOT part of value(message) in ETCD key-value store */
    uint32 fibTableID = 1;              /* ID of FIB table where to install Policy entry */
    bool srhEncapsulation = 2;          /* are SR headers handled by encapsulation? (no means insertion of SR headers) */
    bool sprayBehaviour = 3;            /* spray(multicast) to all policy segments? (no means to use PolicySegment.weight to loadbalance traffic)*/
}

/* Model for segment of SRv6 policy (etcd key for segment has as prefix the etcd key for policy where it belongs) */
message PolicySegment {
    uint32 weight = 1;                  /* used for loadbalancing in case of multiple policy segments in routing process (ignored in case of spray policies) */
    repeated string segments = 2;       /* list of sids creating one segmented road */
}

/* Model for steering traffic to SRv6 policy */
message Steering {
    string policyBSID = 1;              /* BSID identifier for policy to which we want to steer routing into (policyBSID and policyIndex are mutual exclusive) */
    uint32 policyIndex = 2;             /* (vpp-internal)Index identifier for policy to which we want to steer routing into (policyBSID and policyIndex are mutual exclusive) */

    /* Traffic configuration (all traffic messages are mutual exclusive)*/
    L2Traffic l2Traffic = 3;
    L3Traffic l3Traffic = 4;

    message L2Traffic {                 /* L2 traffic that should be steered into SR policy */
        string interfaceName = 1;       /* name of interface with incomming traffic that should be steered to SR policy */
    }
    message L3Traffic {                 /* L3 traffic that should be steered into SR policy */
        uint32 fibTableID = 1;          /* ID of FIB table where to install FIB entry for the BSID */
        string prefixAddress = 2;       /* IPv4/IPv6 prefix address(CIRD format) of traffic destination. All traffic with given destination will be steered to given SR policy */
    }
}
